/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

/**
 * @warning This file is intended for browser usage only.
 * For Node.js environments, import Image and Audio directly from '@boundaryml/baml'.
 * Example:
 * ```ts
 * // ✅ Browser usage
 * import { Image, Audio } from '@boundaryml/baml/browser'
 *
 * // ❌ Don't import these from '@boundaryml/baml' in browser environments
 * import { Image, Audio } from '@boundaryml/baml'
 * ```
 */
/**
 * Browser-compatible implementation of BamlImage
 */
export class BamlImage {
  private constructor(
    private readonly type: 'url' | 'base64',
    private readonly content: string,
    private readonly mediaType?: string,
  ) {}

  /**
   * Create a BamlImage from a URL
   */
  static fromUrl(url: string, mediaType?: string): BamlImage {
    return new BamlImage('url', url, mediaType)
  }

  /**
   * Create a BamlImage from base64 encoded data
   */
  static fromBase64(mediaType: string, base64: string): BamlImage {
    return new BamlImage('base64', base64, mediaType)
  }

  /**
   * Create a BamlImage from a File object
   */
  static async fromFile(file: File): Promise<BamlImage> {
    return BamlImage.fromBlob(file, file.type)
  }

  /**
   * Create a BamlImage from a Blob object
   */
  static async fromBlob(blob: Blob, mediaType?: string): Promise<BamlImage> {
    const base64 = await new Promise<string>((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = () => resolve(reader.result as string)
      reader.onerror = reject
      reader.readAsDataURL(blob)
    })
    // Remove the data URL prefix to get just the base64 string
    const base64Data = base64.replace(/^data:.*?;base64,/, '')
    return BamlImage.fromBase64(mediaType || blob.type, base64Data)
  }

  /**
   * Create a BamlImage by fetching from a URL
   */
  static async fromUrlToBase64(url: string): Promise<BamlImage> {
    const response = await fetch(url)
    const blob = await response.blob()
    return BamlImage.fromBlob(blob)
  }

  /**
   * Check if the image is stored as a URL
   */
  isUrl(): boolean {
    return this.type === 'url'
  }

  /**
   * Get the URL of the image if it's stored as a URL
   * @throws Error if the image is not stored as a URL
   */
  asUrl(): string {
    if (!this.isUrl()) {
      throw new Error('Image is not a URL')
    }
    return this.content
  }

  /**
   * Get the base64 data and media type if the image is stored as base64
   * @returns [base64Data, mediaType]
   * @throws Error if the image is not stored as base64
   */
  asBase64(): [string, string] {
    if (this.type !== 'base64') {
      throw new Error('Image is not base64')
    }
    return [this.content, this.mediaType || '']
  }

  /**
   * Convert the image to a JSON representation
   */
  toJSON(): { url: string } | { base64: string; media_type: string } {
    if (this.type === 'url') {
      return { url: this.content }
    }
    return {
      base64: this.content,
      media_type: this.mediaType || '',
    }
  }
}

/**
 * Browser-compatible implementation of BamlAudio
 */
export class BamlAudio {
  private constructor(
    private readonly type: 'url' | 'base64',
    private readonly content: string,
    private readonly mediaType?: string,
  ) {}

  /**
   * Create a BamlAudio from a URL
   */
  static fromUrl(url: string, mediaType?: string): BamlAudio {
    return new BamlAudio('url', url, mediaType);
  }

  /**
   * Create a BamlAudio from base64 encoded data
   */
  static fromBase64(mediaType: string, base64: string): BamlAudio {
    return new BamlAudio('base64', base64, mediaType);
  }

  /**
   * Create a BamlAudio from a File object
   */
  static async fromFile(file: File): Promise<BamlAudio> {
    return BamlAudio.fromBlob(file, file.type);
  }

  /**
   * Create a BamlAudio from a Blob object
   */
  static async fromBlob(blob: Blob, mediaType?: string): Promise<BamlAudio> {
    const base64 = await new Promise<string>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    // Remove the data URL prefix to get just the base64 string
    const base64Data = base64.replace(/^data:.*?;base64,/, '');
    return BamlAudio.fromBase64(mediaType || blob.type, base64Data);
  }

  /**
   * Create a BamlAudio by fetching from a URL
   */
  static async fromUrlToBase64(url: string): Promise<BamlAudio> {
    const response = await fetch(url);
    const blob = await response.blob();
    return BamlAudio.fromBlob(blob);
  }

  /**
   * Check if the audio is stored as a URL
   */
  isUrl(): boolean {
    return this.type === 'url';
  }

  /**
   * Get the URL of the audio if it's stored as a URL
   * @throws Error if the audio is not stored as a URL
   */
  asUrl(): string {
    if (!this.isUrl()) {
      throw new Error('Audio is not a URL');
    }
    return this.content;
  }

  /**
   * Get the base64 data and media type if the audio is stored as base64
   * @returns [base64Data, mediaType]
   * @throws Error if the audio is not stored as base64
   */
  asBase64(): [string, string] {
    if (this.type !== 'base64') {
      throw new Error('Audio is not base64');
    }
    return [this.content, this.mediaType || ''];
  }

  /**
   * Convert the audio to a JSON representation
   */
  toJSON(): { url: string } | { base64: string; media_type: string } {
    if (this.type === 'url') {
      return { url: this.content };
    }
    return {
      base64: this.content,
      media_type: this.mediaType || '',
    };
  }
}

// Detect if we're in server-side rendering environment
const isSSR = typeof window === 'undefined';

// Create a proxy handler that logs warnings in SSR environment
function createSSRProxyHandler<T extends object>(
  name: string,
): ProxyHandler<T> {
  return {
    get: (target, prop) => {
      if (isSSR) {
        console.warn(
          `Using ${name} from '@boundaryml/baml/browser' in a server-side environment. This will not function properly in SSR.`,
        );
      }
      return (target as Record<string | symbol, unknown>)[prop];
    },
  };
}

// Create proxied versions that will work in both environments but warn in SSR
const ImageImpl = new Proxy(
  BamlImage,
  createSSRProxyHandler<typeof BamlImage>('Image'),
);
const AudioImpl = new Proxy(
  BamlAudio,
  createSSRProxyHandler<typeof BamlAudio>('Audio'),
);

// Now export everything properly
// First, define the type alias
export type Image = BamlImageType;
export type Audio = BamlAudioType;

// Then export the implementations
export { ImageImpl as Image, AudioImpl as Audio };

