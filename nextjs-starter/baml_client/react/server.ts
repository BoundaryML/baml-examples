/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use server'

import { b } from '../index';
import type { Check, Checked } from "../types"
import type { ServerAction } from "./types"
import type { Image, Audio } from "@boundaryml/baml"
import type {Answer, BookAnalysis, CharacterDescription, Citation, Context, Document, Education, Experience, Guide, Ingredient, Link, Message, PartIngredient, PartSteps, Person, PopularityOverTime, Query, Ranking, Recipe, Reply, Resume, Score, Spells, Tweet, Van, VanSideAnalysis, VehicleSideResponse, Visibility, WordCount, Category, ReplyType, Role, VehicleSide} from "../types"
/**
 * Server action for the AnalyzeBooks BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: BookAnalysis
 * - Streaming: ReadableStream
 */
export const AnalyzeBooksAction = async (
  input: string,
): Promise<BookAnalysis> => {
  return b.AnalyzeBooks(
    input,
  );
};

export const AnalyzeBooksStreamingAction = async (
  input: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.AnalyzeBooks(
    input,
  );
  return stream.toStreamable();
};

/**
 * Server action for the AnalyzeVanSide BAML function.
 *
 * Input Types:
 *
 * - vanImage: Image
 *
 *
 * Return Type:
 * - Non-streaming: VanSideAnalysis
 * - Streaming: ReadableStream
 */
export const AnalyzeVanSideAction = async (
  vanImage: Image,
): Promise<VanSideAnalysis> => {
  return b.AnalyzeVanSide(
    vanImage,
  );
};

export const AnalyzeVanSideStreamingAction = async (
  vanImage: Image,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.AnalyzeVanSide(
    vanImage,
  );
  return stream.toStreamable();
};

/**
 * Server action for the AnswerQuestion BAML function.
 *
 * Input Types:
 *
 * - question: string
 *
 * - context: Context
 *
 *
 * Return Type:
 * - Non-streaming: Answer
 * - Streaming: ReadableStream
 */
export const AnswerQuestionAction = async (
  question: string,
  context: Context,
): Promise<Answer> => {
  return b.AnswerQuestion(
    question,
    context,
  );
};

export const AnswerQuestionStreamingAction = async (
  question: string,
  context: Context,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.AnswerQuestion(
    question,
    context,
  );
  return stream.toStreamable();
};

/**
 * Server action for the ClassifyMessage BAML function.
 *
 * Input Types:
 *
 * - convo: Message[]
 *
 *
 * Return Type:
 * - Non-streaming: Category[]
 * - Streaming: ReadableStream
 */
export const ClassifyMessageAction = async (
  convo: Message[],
): Promise<Category[]> => {
  return b.ClassifyMessage(
    convo,
  );
};

export const ClassifyMessageStreamingAction = async (
  convo: Message[],
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.ClassifyMessage(
    convo,
  );
  return stream.toStreamable();
};

/**
 * Server action for the DescribeCharacter BAML function.
 *
 * Input Types:
 *
 * - first_image: Image
 *
 *
 * Return Type:
 * - Non-streaming: CharacterDescription
 * - Streaming: ReadableStream
 */
export const DescribeCharacterAction = async (
  first_image: Image,
): Promise<CharacterDescription> => {
  return b.DescribeCharacter(
    first_image,
  );
};

export const DescribeCharacterStreamingAction = async (
  first_image: Image,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.DescribeCharacter(
    first_image,
  );
  return stream.toStreamable();
};

/**
 * Server action for the ExtractPerson BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Person
 * - Streaming: ReadableStream
 */
export const ExtractPersonAction = async (
  input: string,
): Promise<Person> => {
  return b.ExtractPerson(
    input,
  );
};

export const ExtractPersonStreamingAction = async (
  input: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.ExtractPerson(
    input,
  );
  return stream.toStreamable();
};

/**
 * Server action for the ExtractResume BAML function.
 *
 * Input Types:
 *
 * - raw_text: string
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming: ReadableStream
 */
export const ExtractResumeAction = async (
  raw_text: string,
): Promise<Resume> => {
  return b.ExtractResume(
    raw_text,
  );
};

export const ExtractResumeStreamingAction = async (
  raw_text: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.ExtractResume(
    raw_text,
  );
  return stream.toStreamable();
};

/**
 * Server action for the ExtractResumeNoStructure BAML function.
 *
 * Input Types:
 *
 * - raw_text: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const ExtractResumeNoStructureAction = async (
  raw_text: string,
): Promise<string> => {
  return b.ExtractResumeNoStructure(
    raw_text,
  );
};

export const ExtractResumeNoStructureStreamingAction = async (
  raw_text: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.ExtractResumeNoStructure(
    raw_text,
  );
  return stream.toStreamable();
};

/**
 * Server action for the GenerateGuide BAML function.
 *
 * Input Types:
 *
 * - arg: string
 *
 *
 * Return Type:
 * - Non-streaming: Guide
 * - Streaming: ReadableStream
 */
export const GenerateGuideAction = async (
  arg: string,
): Promise<Guide> => {
  return b.GenerateGuide(
    arg,
  );
};

export const GenerateGuideStreamingAction = async (
  arg: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.GenerateGuide(
    arg,
  );
  return stream.toStreamable();
};

/**
 * Server action for the GenerateReplies BAML function.
 *
 * Input Types:
 *
 * - tweets: Tweet[]
 *
 *
 * Return Type:
 * - Non-streaming: Reply[]
 * - Streaming: ReadableStream
 */
export const GenerateRepliesAction = async (
  tweets: Tweet[],
): Promise<Reply[]> => {
  return b.GenerateReplies(
    tweets,
  );
};

export const GenerateRepliesStreamingAction = async (
  tweets: Tweet[],
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.GenerateReplies(
    tweets,
  );
  return stream.toStreamable();
};

/**
 * Server action for the GetRecipe BAML function.
 *
 * Input Types:
 *
 * - arg: string
 *
 *
 * Return Type:
 * - Non-streaming: Recipe
 * - Streaming: ReadableStream
 */
export const GetRecipeAction = async (
  arg: string,
): Promise<Recipe> => {
  return b.GetRecipe(
    arg,
  );
};

export const GetRecipeStreamingAction = async (
  arg: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.GetRecipe(
    arg,
  );
  return stream.toStreamable();
};

/**
 * Server action for the IdentifyVehicleSide BAML function.
 *
 * Input Types:
 *
 * - vanImage: Image
 *
 *
 * Return Type:
 * - Non-streaming: VehicleSideResponse
 * - Streaming: ReadableStream
 */
export const IdentifyVehicleSideAction = async (
  vanImage: Image,
): Promise<VehicleSideResponse> => {
  return b.IdentifyVehicleSide(
    vanImage,
  );
};

export const IdentifyVehicleSideStreamingAction = async (
  vanImage: Image,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.IdentifyVehicleSide(
    vanImage,
  );
  return stream.toStreamable();
};

/**
 * Server action for the IsResume BAML function.
 *
 * Input Types:
 *
 * - raw_text: string
 *
 *
 * Return Type:
 * - Non-streaming: boolean
 * - Streaming: ReadableStream
 */
export const IsResumeAction = async (
  raw_text: string,
): Promise<boolean> => {
  return b.IsResume(
    raw_text,
  );
};

export const IsResumeStreamingAction = async (
  raw_text: string,
): Promise<ReadableStream<Uint8Array>> => {
  const stream = b.stream.IsResume(
    raw_text,
  );
  return stream.toStreamable();
};
