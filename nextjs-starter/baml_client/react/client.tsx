/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import { useCallback, useMemo, useReducer, useTransition } from 'react';
import type {
  StreamingProps,
  NonStreamingProps,
  StreamingHookResult,
  NonStreamingHookResult,
  HookProps,
  PartialReturnType,
  FinalReturnType,
  ServerAction,
  BamlStreamResponse,
  ActionKey,
} from './types';
import { BamlValidationError, BamlClientFinishReasonError } from "@boundaryml/baml/errors";
import * as Actions from './server';
import * as StreamingActions from './server_streaming'

/**
 * Type guard to check if the hook props are configured for streaming mode.
 *
 * @template TActionKey - The key of the Actions namespace.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate streaming mode.
 */
function isStreamingProps<TActionKey extends ActionKey>(
  props: HookProps<TActionKey>
): props is StreamingProps<TActionKey> {
  return props.stream === true;
}

function isBamlError(error?: Error | BamlValidationError | BamlClientFinishReasonError): error is (BamlValidationError | BamlClientFinishReasonError) & { type: string } {
  const errorType = (error as any)?.type;
  return errorType === 'BamlValidationError' || errorType === 'BamlClientFinishReasonError';
}

interface HookState<TPartial, TFinal> {
  isSuccess: boolean;
  error?: Error | BamlValidationError | BamlClientFinishReasonError;
  data?: TFinal;
  partialData?: TPartial;
}

type HookStateAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: Error | BamlValidationError | BamlClientFinishReasonError }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' };

/**
 * Reducer function to manage the hook state transitions.
 *
 * @template TPartial - The type of the partial (streaming) data.
 * @template TFinal - The type of the final (non‑streaming) data.
 * @param state - The current hook state.
 * @param action - The action to apply.
 * @returns The updated state.
 */
function hookReducer<TPartial, TFinal>(
  state: HookState<TPartial, TFinal>,
  action: HookStateAction<TPartial, TFinal>
): HookState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        ...state,
        isSuccess: false,
        error: undefined,
        data: undefined,
        partialData: undefined,
      };
    case 'SET_ERROR':
      return {
        ...state,
        isSuccess: false,
        error: action.payload,
        data: undefined,
        partialData: undefined,
      };
    case 'SET_PARTIAL':
      return {
        ...state,
        partialData: action.payload,
      };
    case 'SET_FINAL':
      return {
        ...state,
        isSuccess: true,
        data: action.payload,
        partialData: undefined,
      };
    case 'RESET':
      return {
        isSuccess: false,
        error: undefined,
        data: undefined,
        partialData: undefined,
      };
    default:
      return state;
  }
}

/**
 * Base hook for executing BAML server actions, supporting both streaming and non‑streaming modes.
 *
 * This hook provides a unified interface for handling loading states, partial updates, errors,
 * and final responses. It is designed to be used directly with any BAML server action.
 *
 * Features:
 * - **Streaming Support:** Real‑time partial updates via `partialData`, progress indicators, and incremental UI updates.
 * - **State Management:** Manages loading state (`isPending`), success/error flags, and final/partial results.
 * - **Error Handling:** Supports type‑safe error handling for BamlValidationError, BamlClientFinishReasonError, and standard errors.
 *
 * @param Action - The server action to invoke.
 * @param props - Configuration props for the hook.
 * @returns An object with the current state and a `mutate` function to trigger the action.
 *
 * @example
 * ```tsx
 * const { data, error, isPending, mutate } = useBamlAction(StreamingActions.TestAws, { stream: true });
 * ```
 */
export function useBamlAction<TActionKey extends ActionKey>(
  action: ServerAction,
  props: StreamingProps<TActionKey>
): StreamingHookResult<TActionKey>;

export function useBamlAction<TActionKey extends ActionKey>(
  action: ServerAction,
  props?: NonStreamingProps<TActionKey>
): NonStreamingHookResult<TActionKey>;

export function useBamlAction<TActionKey extends ActionKey>(
  action: ServerAction,
  props: HookProps<TActionKey> = {}
): StreamingHookResult<TActionKey> | NonStreamingHookResult<TActionKey> {
  const { onFinal, onError, onPartial } = props;
  const isStreaming = isStreamingProps(props);
  const [isPending, startTransition] = useTransition();

  const [state, dispatch] = useReducer(
    hookReducer<PartialReturnType<TActionKey>, FinalReturnType<TActionKey>>,
    {
      isSuccess: false,
      error: undefined,
      data: undefined,
      partialData: undefined,
    }
  );

  const mutate = useCallback(
    async (...input: Parameters<ServerAction>) => {
      dispatch({ type: 'START_REQUEST' });
      try {
        let response: Awaited<ReturnType<ServerAction>>;
        startTransition(async () => {
          response = await action(...input);
          if (isStreaming && response instanceof ReadableStream) {
            const reader = response.getReader();
            const decoder = new TextDecoder();
            try {
              while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                  const chunk = decoder.decode(value, { stream: true }).trim();
                  try {
                    const parsed: BamlStreamResponse<PartialReturnType<TActionKey>, FinalReturnType<TActionKey>> = JSON.parse(chunk);
                    if (parsed.error) {
                      let error: Error | BamlValidationError | BamlClientFinishReasonError = new Error('Unknown error')

                      if (isBamlError(parsed.error)) {
                        if (parsed.error?.type === 'BamlValidationError') {
                          error = new BamlValidationError(
                            parsed.error.prompt,
                            parsed.error.raw_output,
                            parsed.error.message,
                          )
                        } else if (parsed.error.type === 'BamlClientFinishReasonError') {
                          error = new BamlClientFinishReasonError(
                            parsed.error.prompt,
                            parsed.error.raw_output,
                            parsed.error.message,
                          )
                        }
                      } else {
                        error = new Error(parsed.error.message)
                      }
                      throw error;
                    }
                    if (parsed.partial !== undefined) {
                      dispatch({ type: 'SET_PARTIAL', payload: parsed.partial });
                      onPartial?.(parsed.partial);
                    }
                    if (parsed.final !== undefined) {
                      dispatch({ type: 'SET_FINAL', payload: parsed.final });
                      onFinal?.(parsed.final);
                      return;
                    }
                  } catch (err: unknown) {
                    dispatch({ type: "SET_ERROR", payload: err as Error | BamlValidationError | BamlClientFinishReasonError });
                    onError?.(err as Error | BamlValidationError | BamlClientFinishReasonError);
                    break;
                  }
                }
              }
            } finally {
              reader.releaseLock();
            }
            return;
          }
          // Non‑streaming case
          dispatch({ type: 'SET_FINAL', payload: response });
          onFinal?.(response);
        });
        return response;
      } catch (error_: unknown) {
        dispatch({ type: 'SET_ERROR', payload: error_ as Error | BamlValidationError | BamlClientFinishReasonError });
        onError?.(error_ as Error | BamlValidationError | BamlClientFinishReasonError);
        throw error_;
      }
    },
    [action, isStreaming, onPartial, onFinal, onError]
  );

  const status = useMemo<"idle" | "pending" | "success" | "error">(() => {
    if (isPending) return "pending";
    if (state.error) return "error";
    if (state.isSuccess) return "success";
    return "idle";
  }, [isPending, state.error, state.isSuccess]);

  const result = {
    data: state.data,
    error: state.error,
    isError: !!state.error,
    isSuccess: state.isSuccess,
    isPending,
    mutate,
    status,
  };

  return {
    ...result,
    partialData: isStreaming ? state.partialData : undefined,
  };
}
/**
 * A specialized hook for the AnalyzeBooks BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** BookAnalysis
 * - **Streaming Partial:** partial_types.BookAnalysis
 * - **Streaming Final:** BookAnalysis
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAnalyzeBooks();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAnalyzeBooks({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeBooks(
  props: StreamingProps<'AnalyzeBooks'>
): StreamingHookResult<'AnalyzeBooks'>;

export function useAnalyzeBooks(
  props?: NonStreamingProps<'AnalyzeBooks'>
): NonStreamingHookResult<'AnalyzeBooks'>;

export function useAnalyzeBooks(
  props: HookProps<'AnalyzeBooks'> = {}
): StreamingHookResult<'AnalyzeBooks'> | NonStreamingHookResult<'AnalyzeBooks'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AnalyzeBooks, props);
  }

  return useBamlAction(Actions.AnalyzeBooks, props);
}
/**
 * A specialized hook for the AnalyzeVanSide BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - vanImage: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** VanSideAnalysis
 * - **Streaming Partial:** partial_types.VanSideAnalysis
 * - **Streaming Final:** VanSideAnalysis
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAnalyzeVanSide();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAnalyzeVanSide({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeVanSide(
  props: StreamingProps<'AnalyzeVanSide'>
): StreamingHookResult<'AnalyzeVanSide'>;

export function useAnalyzeVanSide(
  props?: NonStreamingProps<'AnalyzeVanSide'>
): NonStreamingHookResult<'AnalyzeVanSide'>;

export function useAnalyzeVanSide(
  props: HookProps<'AnalyzeVanSide'> = {}
): StreamingHookResult<'AnalyzeVanSide'> | NonStreamingHookResult<'AnalyzeVanSide'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AnalyzeVanSide, props);
  }

  return useBamlAction(Actions.AnalyzeVanSide, props);
}
/**
 * A specialized hook for the AnswerQuestion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - question: string
 *
 * - context: Context
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Answer
 * - **Streaming Partial:** partial_types.Answer
 * - **Streaming Final:** Answer
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAnswerQuestion();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAnswerQuestion({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnswerQuestion(
  props: StreamingProps<'AnswerQuestion'>
): StreamingHookResult<'AnswerQuestion'>;

export function useAnswerQuestion(
  props?: NonStreamingProps<'AnswerQuestion'>
): NonStreamingHookResult<'AnswerQuestion'>;

export function useAnswerQuestion(
  props: HookProps<'AnswerQuestion'> = {}
): StreamingHookResult<'AnswerQuestion'> | NonStreamingHookResult<'AnswerQuestion'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AnswerQuestion, props);
  }

  return useBamlAction(Actions.AnswerQuestion, props);
}
/**
 * A specialized hook for the ClassifyMessage BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - convo: Message[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category[]
 * - **Streaming Partial:** (Category | null)[]
 * - **Streaming Final:** Category[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useClassifyMessage({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage(
  props: StreamingProps<'ClassifyMessage'>
): StreamingHookResult<'ClassifyMessage'>;

export function useClassifyMessage(
  props?: NonStreamingProps<'ClassifyMessage'>
): NonStreamingHookResult<'ClassifyMessage'>;

export function useClassifyMessage(
  props: HookProps<'ClassifyMessage'> = {}
): StreamingHookResult<'ClassifyMessage'> | NonStreamingHookResult<'ClassifyMessage'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ClassifyMessage, props);
  }

  return useBamlAction(Actions.ClassifyMessage, props);
}
/**
 * A specialized hook for the DescribeCharacter BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - first_image: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** CharacterDescription
 * - **Streaming Partial:** partial_types.CharacterDescription
 * - **Streaming Final:** CharacterDescription
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeCharacter();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDescribeCharacter({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeCharacter(
  props: StreamingProps<'DescribeCharacter'>
): StreamingHookResult<'DescribeCharacter'>;

export function useDescribeCharacter(
  props?: NonStreamingProps<'DescribeCharacter'>
): NonStreamingHookResult<'DescribeCharacter'>;

export function useDescribeCharacter(
  props: HookProps<'DescribeCharacter'> = {}
): StreamingHookResult<'DescribeCharacter'> | NonStreamingHookResult<'DescribeCharacter'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DescribeCharacter, props);
  }

  return useBamlAction(Actions.DescribeCharacter, props);
}
/**
 * A specialized hook for the ExtractPerson BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Person
 * - **Streaming Partial:** partial_types.Person
 * - **Streaming Final:** Person
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractPerson();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractPerson({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractPerson(
  props: StreamingProps<'ExtractPerson'>
): StreamingHookResult<'ExtractPerson'>;

export function useExtractPerson(
  props?: NonStreamingProps<'ExtractPerson'>
): NonStreamingHookResult<'ExtractPerson'>;

export function useExtractPerson(
  props: HookProps<'ExtractPerson'> = {}
): StreamingHookResult<'ExtractPerson'> | NonStreamingHookResult<'ExtractPerson'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractPerson, props);
  }

  return useBamlAction(Actions.ExtractPerson, props);
}
/**
 * A specialized hook for the ExtractResume BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - raw_text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Resume
 * - **Streaming Partial:** partial_types.Resume
 * - **Streaming Final:** Resume
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractResume();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractResume({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResume(
  props: StreamingProps<'ExtractResume'>
): StreamingHookResult<'ExtractResume'>;

export function useExtractResume(
  props?: NonStreamingProps<'ExtractResume'>
): NonStreamingHookResult<'ExtractResume'>;

export function useExtractResume(
  props: HookProps<'ExtractResume'> = {}
): StreamingHookResult<'ExtractResume'> | NonStreamingHookResult<'ExtractResume'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractResume, props);
  }

  return useBamlAction(Actions.ExtractResume, props);
}
/**
 * A specialized hook for the ExtractResumeNoStructure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - raw_text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractResumeNoStructure();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractResumeNoStructure({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResumeNoStructure(
  props: StreamingProps<'ExtractResumeNoStructure'>
): StreamingHookResult<'ExtractResumeNoStructure'>;

export function useExtractResumeNoStructure(
  props?: NonStreamingProps<'ExtractResumeNoStructure'>
): NonStreamingHookResult<'ExtractResumeNoStructure'>;

export function useExtractResumeNoStructure(
  props: HookProps<'ExtractResumeNoStructure'> = {}
): StreamingHookResult<'ExtractResumeNoStructure'> | NonStreamingHookResult<'ExtractResumeNoStructure'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractResumeNoStructure, props);
  }

  return useBamlAction(Actions.ExtractResumeNoStructure, props);
}
/**
 * A specialized hook for the GenerateGuide BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - arg: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Guide
 * - **Streaming Partial:** partial_types.Guide
 * - **Streaming Final:** Guide
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGenerateGuide();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useGenerateGuide({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateGuide(
  props: StreamingProps<'GenerateGuide'>
): StreamingHookResult<'GenerateGuide'>;

export function useGenerateGuide(
  props?: NonStreamingProps<'GenerateGuide'>
): NonStreamingHookResult<'GenerateGuide'>;

export function useGenerateGuide(
  props: HookProps<'GenerateGuide'> = {}
): StreamingHookResult<'GenerateGuide'> | NonStreamingHookResult<'GenerateGuide'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.GenerateGuide, props);
  }

  return useBamlAction(Actions.GenerateGuide, props);
}
/**
 * A specialized hook for the GenerateReplies BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - tweets: Tweet[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Reply[]
 * - **Streaming Partial:** (partial_types.Reply | null)[]
 * - **Streaming Final:** Reply[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGenerateReplies();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useGenerateReplies({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateReplies(
  props: StreamingProps<'GenerateReplies'>
): StreamingHookResult<'GenerateReplies'>;

export function useGenerateReplies(
  props?: NonStreamingProps<'GenerateReplies'>
): NonStreamingHookResult<'GenerateReplies'>;

export function useGenerateReplies(
  props: HookProps<'GenerateReplies'> = {}
): StreamingHookResult<'GenerateReplies'> | NonStreamingHookResult<'GenerateReplies'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.GenerateReplies, props);
  }

  return useBamlAction(Actions.GenerateReplies, props);
}
/**
 * A specialized hook for the GetRecipe BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - arg: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Recipe
 * - **Streaming Partial:** partial_types.Recipe
 * - **Streaming Final:** Recipe
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetRecipe();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useGetRecipe({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetRecipe(
  props: StreamingProps<'GetRecipe'>
): StreamingHookResult<'GetRecipe'>;

export function useGetRecipe(
  props?: NonStreamingProps<'GetRecipe'>
): NonStreamingHookResult<'GetRecipe'>;

export function useGetRecipe(
  props: HookProps<'GetRecipe'> = {}
): StreamingHookResult<'GetRecipe'> | NonStreamingHookResult<'GetRecipe'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.GetRecipe, props);
  }

  return useBamlAction(Actions.GetRecipe, props);
}
/**
 * A specialized hook for the IdentifyVehicleSide BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - vanImage: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** VehicleSideResponse
 * - **Streaming Partial:** partial_types.VehicleSideResponse
 * - **Streaming Final:** VehicleSideResponse
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useIdentifyVehicleSide();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useIdentifyVehicleSide({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useIdentifyVehicleSide(
  props: StreamingProps<'IdentifyVehicleSide'>
): StreamingHookResult<'IdentifyVehicleSide'>;

export function useIdentifyVehicleSide(
  props?: NonStreamingProps<'IdentifyVehicleSide'>
): NonStreamingHookResult<'IdentifyVehicleSide'>;

export function useIdentifyVehicleSide(
  props: HookProps<'IdentifyVehicleSide'> = {}
): StreamingHookResult<'IdentifyVehicleSide'> | NonStreamingHookResult<'IdentifyVehicleSide'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.IdentifyVehicleSide, props);
  }

  return useBamlAction(Actions.IdentifyVehicleSide, props);
}
/**
 * A specialized hook for the IsResume BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - raw_text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** boolean
 * - **Streaming Partial:** boolean
 * - **Streaming Final:** boolean
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useIsResume();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useIsResume({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useIsResume(
  props: StreamingProps<'IsResume'>
): StreamingHookResult<'IsResume'>;

export function useIsResume(
  props?: NonStreamingProps<'IsResume'>
): NonStreamingHookResult<'IsResume'>;

export function useIsResume(
  props: HookProps<'IsResume'> = {}
): StreamingHookResult<'IsResume'> | NonStreamingHookResult<'IsResume'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.IsResume, props);
  }

  return useBamlAction(Actions.IsResume, props);
}
/**
 * A specialized hook for the MakeSemanticContainer BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SemanticContainer
 * - **Streaming Partial:** partial_types.SemanticContainer
 * - **Streaming Final:** SemanticContainer
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeSemanticContainer();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMakeSemanticContainer({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeSemanticContainer(
  props: StreamingProps<'MakeSemanticContainer'>
): StreamingHookResult<'MakeSemanticContainer'>;

export function useMakeSemanticContainer(
  props?: NonStreamingProps<'MakeSemanticContainer'>
): NonStreamingHookResult<'MakeSemanticContainer'>;

export function useMakeSemanticContainer(
  props: HookProps<'MakeSemanticContainer'> = {}
): StreamingHookResult<'MakeSemanticContainer'> | NonStreamingHookResult<'MakeSemanticContainer'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MakeSemanticContainer, props);
  }

  return useBamlAction(Actions.MakeSemanticContainer, props);
}