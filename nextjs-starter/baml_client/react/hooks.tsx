/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import type { BamlErrors } from '@boundaryml/baml/errors'
import { toBamlError } from '@boundaryml/baml/errors'
import { useCallback, useMemo, useReducer, useTransition } from 'react'
import * as Actions from './server'
import * as StreamingActions from './server_streaming'
import type { StreamingServerTypes } from './server_streaming_types'

/**
 * Type representing a BAML stream response.
 *
 * @template PartialType The type of the partial response.
 * @template FinalType The type of the final response.
 */
type BamlStreamResponse<PartialType, FinalType> = {
  partial?: PartialType
  final?: FinalType
  error?: BamlErrors
}

/**
 * A server action that returns either a ReadableStream of Uint8Array or a final output.
 */
export type ServerAction<Input = any, Output = any> = (
  ...args: Input extends any[] ? Input : [Input]
) => Promise<Output> | ReadableStream<Uint8Array>

/**
 * Type representing all function names except 'stream' and 'stream_types'
 */
export type FunctionNames = keyof typeof Actions

/**
 * Helper type to derive the partial return type for an action.
 */
type StreamDataType<FunctionName extends FunctionNames> = StreamingServerTypes[FunctionName]

/**
 * Helper type to derive the final return type for an action.
 */
type FinalDataType<FunctionName extends FunctionNames> = (typeof Actions)[FunctionName] extends (...args: any) => any
  ? Awaited<ReturnType<(typeof Actions)[FunctionName]>>
  : never

/**
 * Configuration options for BAML React hooks.
 */
export type HookInput<FunctionName extends FunctionNames = FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = {
  stream?: Options['stream']
  onStreamData?: Options['stream'] extends false ? never : (response?: StreamDataType<FunctionName>) => void
  onFinalData?: (response?: FinalDataType<FunctionName>) => void
  onData?: (response?: Options['stream'] extends false ? FinalDataType<FunctionName> : FinalDataType<FunctionName> | StreamDataType<FunctionName>) => void
  onError?: (error: BamlErrors) => void
}

export type NonStreamingHookStatus = 'idle' | 'pending' | 'success' | 'error'
export type StreamingHookStatus = NonStreamingHookStatus | 'streaming'

export type HookStatus<Options extends { stream?: boolean } = { stream?: true }> = Options['stream'] extends false
  ? NonStreamingHookStatus
  : StreamingHookStatus

/**
 * Return type for BAML React hooks.
 */
export type HookOutput<FunctionName extends FunctionNames = FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = {
  data?: Options['stream'] extends false ? FinalDataType<FunctionName> : FinalDataType<FunctionName> | StreamDataType<FunctionName>
  finalData?: FinalDataType<FunctionName>
  streamData?: Options['stream'] extends false ? never : StreamDataType<FunctionName>
  isLoading: boolean
  isPending: boolean
  isStreaming: Options['stream'] extends false ? never : boolean
  isSuccess: boolean
  isError: boolean
  error?: BamlErrors
  status: HookStatus<Options>
  mutate: (
    ...args: Parameters<(typeof Actions)[FunctionName]>
  ) => Options['stream'] extends false ? Promise<FinalDataType<FunctionName>> : Promise<ReadableStream<Uint8Array>>
  reset: () => void
}

export type HookData<FunctionName extends FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = NonNullable<HookOutput<FunctionName, Options>['data']>;

/**
 * Type guard to check if the hook props are configured for streaming mode.
 *
 * @template FunctionName - The name of the BAML function.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate streaming mode.
 */
function isStreamingProps<FunctionName extends FunctionNames>(
  props: HookInput<FunctionName, { stream?: boolean }>,
): props is HookInput<FunctionName, { stream?: true }> {
  return props.stream !== false
}

interface HookState<TPartial, TFinal> {
  isSuccess: boolean
  isStreaming: boolean
  error?: BamlErrors
  finalData?: TFinal
  streamData?: TPartial
}

type HookStateAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: BamlErrors }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' }

/**
 * Reducer function to manage the hook state transitions.
 *
 * @template TPartial - The type of the partial (streaming) data.
 * @template TFinal - The type of the final (non‑streaming) data.
 * @param state - The current hook state.
 * @param action - The action to apply.
 * @returns The updated state.
 */
function hookReducer<TPartial, TFinal>(
  state: HookState<TPartial, TFinal>,
  action: HookStateAction<TPartial, TFinal>,
): HookState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        ...state,
        isSuccess: false,
        error: undefined,
        isStreaming: false,
        finalData: undefined,
        streamData: undefined,
      }
    case 'SET_ERROR':
      return {
        ...state,
        isSuccess: false,
        isStreaming: false,
        error: action.payload,
      }
    case 'SET_PARTIAL':
      return {
        ...state,
        isStreaming: true,
        streamData: action.payload,
      }
    case 'SET_FINAL':
      return {
        ...state,
        isSuccess: true,
        isStreaming: false,
        finalData: action.payload,
      }
    case 'RESET':
      return {
        isSuccess: false,
        isStreaming: false,
        error: undefined,
        finalData: undefined,
        streamData: undefined,
      }
    default:
      return state
  }
}

/**
 * Base hook for executing BAML server actions, supporting both streaming and non‑streaming modes.
 *
 * This hook provides a unified interface for handling loading states, partial updates, errors,
 * and final responses. It is designed to be used directly with any BAML server action.
 *
 * Features:
 * - **Streaming Support:** Real‑time partial updates via `streamData`, progress indicators, and incremental UI updates.
 * - **State Management:** Manages loading state (`isLoading`), success/error flags, and final/partial results.
 * - **Error Handling:** Supports type‑safe error handling for BamlValidationError, BamlClientFinishReasonError, and standard errors.
 *
 * @param Action - The server action to invoke.
 * @param props - Configuration props for the hook.
 * @returns An object with the current state and a `mutate` function to trigger the action.
 *
 * @example
 * ```tsx
 * const { data, error, isLoading, mutate } = useBamlAction(StreamingActions.TestAws, { stream: true });
 * ```
 */
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream: false }>,
): HookOutput<FunctionName, { stream: false }>
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props?: HookInput<FunctionName, { stream?: true }>,
): HookOutput<FunctionName, { stream: true }>
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream?: boolean }> = {},
): HookOutput<FunctionName, { stream: true }> | HookOutput<FunctionName, { stream: false }> {
  const { onFinalData, onError } = props
  const [isLoading, startTransition] = useTransition()

  const [state, dispatch] = useReducer(hookReducer<StreamDataType<FunctionName>, FinalDataType<FunctionName>>, {
    isSuccess: false,
    error: undefined,
    finalData: undefined,
    isStreaming: false,
    streamData: undefined,
  })

  const mutate = useCallback(
    async (...input: Parameters<ServerAction>) => {
      dispatch({ type: 'START_REQUEST' })
      try {
        let response: Awaited<ReturnType<ServerAction>>
        startTransition(async () => {
          // Transform any BamlImage or BamlAudio inputs to their JSON representation
          const transformedInput = input.map(arg => {
            // Check if the argument is an instance of BamlImage or BamlAudio
            // We check the constructor name since the actual classes might be proxied in browser environments
            if (arg && typeof arg === 'object' &&
                (arg.constructor.name === 'BamlImage' || arg.constructor.name === 'BamlAudio')) {
              return arg.toJSON();
            }
            return arg;
          });

          response = await action(...transformedInput)

          if (isStreamingProps(props) && response instanceof ReadableStream) {
            const reader = response.getReader()
            const decoder = new TextDecoder()
            try {
              while (true) {
                const { value, done } = await reader.read()
                if (done) break
                if (value) {
                  const chunk = decoder.decode(value, { stream: true }).trim()
                  try {
                    const parsed: BamlStreamResponse<
                      StreamDataType<FunctionName>,
                      FinalDataType<FunctionName>
                    > = JSON.parse(chunk)
                    if (parsed.error) {
                       if (parsed.error instanceof Error) {
                        throw parsed.error
                      }

                      const parsedError = JSON.parse(parsed.error)
                      const finalError = toBamlError(parsedError)
                      throw finalError
                    }
                    if (parsed.partial !== undefined) {
                      dispatch({ type: 'SET_PARTIAL', payload: parsed.partial })
                      if (isStreamingProps(props)) {
                        props.onStreamData?.(parsed.partial)
                      }
                      props.onData?.(parsed.partial)
                    }
                    if (parsed.final !== undefined) {
                      dispatch({ type: 'SET_FINAL', payload: parsed.final })
                      onFinalData?.(parsed.final)
                      props.onData?.(parsed.final)
                      return
                    }
                  } catch (err: unknown) {
                    dispatch({
                      type: 'SET_ERROR',
                      payload: err as BamlErrors,
                    })
                    onError?.(err as BamlErrors)
                    break
                  }
                }
              }
            } finally {
              reader.releaseLock()
            }
            return
          }
          // Non‑streaming case
          dispatch({ type: 'SET_FINAL', payload: response })
          onFinalData?.(response)
        })
        return response
      } catch (error_: unknown) {
        dispatch({ type: 'SET_ERROR', payload: error_ as BamlErrors })
        onError?.(error_ as BamlErrors)
        throw error_
      }
    },
    [action, onFinalData, onError, props],
  )

  const status = useMemo<HookStatus<{ stream: typeof props.stream }>>(() => {
    if (state.error) return 'error'
    if (state.isSuccess) return 'success'
    if (state.isStreaming) return 'streaming'
    if (isLoading) return 'pending'
    return 'idle'
  }, [isLoading, state.error, state.isSuccess, state.isStreaming])

  let data:
		| FinalDataType<FunctionName>
		| StreamDataType<FunctionName>
		| undefined = state.finalData;
  if (state.isStreaming) data = state.streamData

  const result = {
    data,
    finalData: state.finalData,
    error: state.error,
    isError: status === 'error',
    isSuccess: status === 'success',
    isStreaming: status === 'streaming',
    isPending: status === 'pending',
    isLoading: status === 'pending' || status === 'streaming',
    mutate,
    status,
    reset: () => dispatch({ type: 'RESET' }),
  } satisfies HookOutput<FunctionName, { stream: typeof props.stream }>

  return {
    ...result,
    streamData: isStreamingProps(props) ? state.streamData : undefined,
  } satisfies HookOutput<FunctionName, { stream: typeof props.stream }>
}
/**
 * A specialized hook for the AnalyzeBooks BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** BookAnalysis
 * - **Streaming Partial:** partial_types.BookAnalysis
 * - **Streaming Final:** BookAnalysis
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeBooks({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeBooks({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeBooks(props: HookInput<'AnalyzeBooks', { stream: false }>): HookOutput<'AnalyzeBooks', { stream: false }>
export function useAnalyzeBooks(props?: HookInput<'AnalyzeBooks', { stream?: true }>): HookOutput<'AnalyzeBooks', { stream: true }>
export function useAnalyzeBooks(
  props: HookInput<'AnalyzeBooks', { stream?: boolean }> = {},
): HookOutput<'AnalyzeBooks', { stream: true }> | HookOutput<'AnalyzeBooks', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeBooks;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeBooks;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the AnalyzeVanSide BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - vanImage: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** VanSideAnalysis
 * - **Streaming Partial:** partial_types.VanSideAnalysis
 * - **Streaming Final:** VanSideAnalysis
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnalyzeVanSide({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnalyzeVanSide({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnalyzeVanSide(props: HookInput<'AnalyzeVanSide', { stream: false }>): HookOutput<'AnalyzeVanSide', { stream: false }>
export function useAnalyzeVanSide(props?: HookInput<'AnalyzeVanSide', { stream?: true }>): HookOutput<'AnalyzeVanSide', { stream: true }>
export function useAnalyzeVanSide(
  props: HookInput<'AnalyzeVanSide', { stream?: boolean }> = {},
): HookOutput<'AnalyzeVanSide', { stream: true }> | HookOutput<'AnalyzeVanSide', { stream: false }> {
  let action: ServerAction = Actions.AnalyzeVanSide;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnalyzeVanSide;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the AnswerQuestion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - question: string
 *
 * - context: Context
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Answer
 * - **Streaming Partial:** partial_types.Answer
 * - **Streaming Final:** Answer
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useAnswerQuestion({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useAnswerQuestion({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAnswerQuestion(props: HookInput<'AnswerQuestion', { stream: false }>): HookOutput<'AnswerQuestion', { stream: false }>
export function useAnswerQuestion(props?: HookInput<'AnswerQuestion', { stream?: true }>): HookOutput<'AnswerQuestion', { stream: true }>
export function useAnswerQuestion(
  props: HookInput<'AnswerQuestion', { stream?: boolean }> = {},
): HookOutput<'AnswerQuestion', { stream: true }> | HookOutput<'AnswerQuestion', { stream: false }> {
  let action: ServerAction = Actions.AnswerQuestion;
  if (isStreamingProps(props)) {
    action = StreamingActions.AnswerQuestion;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the ClassifyMessage BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - convo: Message[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category[]
 * - **Streaming Partial:** (Category | null)[]
 * - **Streaming Final:** Category[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useClassifyMessage({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useClassifyMessage({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage(props: HookInput<'ClassifyMessage', { stream: false }>): HookOutput<'ClassifyMessage', { stream: false }>
export function useClassifyMessage(props?: HookInput<'ClassifyMessage', { stream?: true }>): HookOutput<'ClassifyMessage', { stream: true }>
export function useClassifyMessage(
  props: HookInput<'ClassifyMessage', { stream?: boolean }> = {},
): HookOutput<'ClassifyMessage', { stream: true }> | HookOutput<'ClassifyMessage', { stream: false }> {
  let action: ServerAction = Actions.ClassifyMessage;
  if (isStreamingProps(props)) {
    action = StreamingActions.ClassifyMessage;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the DescribeCharacter BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - first_image: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** CharacterDescription
 * - **Streaming Partial:** partial_types.CharacterDescription
 * - **Streaming Final:** CharacterDescription
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useDescribeCharacter({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useDescribeCharacter({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeCharacter(props: HookInput<'DescribeCharacter', { stream: false }>): HookOutput<'DescribeCharacter', { stream: false }>
export function useDescribeCharacter(props?: HookInput<'DescribeCharacter', { stream?: true }>): HookOutput<'DescribeCharacter', { stream: true }>
export function useDescribeCharacter(
  props: HookInput<'DescribeCharacter', { stream?: boolean }> = {},
): HookOutput<'DescribeCharacter', { stream: true }> | HookOutput<'DescribeCharacter', { stream: false }> {
  let action: ServerAction = Actions.DescribeCharacter;
  if (isStreamingProps(props)) {
    action = StreamingActions.DescribeCharacter;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the ExtractPerson BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Person
 * - **Streaming Partial:** partial_types.Person
 * - **Streaming Final:** Person
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useExtractPerson({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useExtractPerson({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractPerson(props: HookInput<'ExtractPerson', { stream: false }>): HookOutput<'ExtractPerson', { stream: false }>
export function useExtractPerson(props?: HookInput<'ExtractPerson', { stream?: true }>): HookOutput<'ExtractPerson', { stream: true }>
export function useExtractPerson(
  props: HookInput<'ExtractPerson', { stream?: boolean }> = {},
): HookOutput<'ExtractPerson', { stream: true }> | HookOutput<'ExtractPerson', { stream: false }> {
  let action: ServerAction = Actions.ExtractPerson;
  if (isStreamingProps(props)) {
    action = StreamingActions.ExtractPerson;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the ExtractResume BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - raw_text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Resume
 * - **Streaming Partial:** partial_types.Resume
 * - **Streaming Final:** Resume
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useExtractResume({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useExtractResume({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResume(props: HookInput<'ExtractResume', { stream: false }>): HookOutput<'ExtractResume', { stream: false }>
export function useExtractResume(props?: HookInput<'ExtractResume', { stream?: true }>): HookOutput<'ExtractResume', { stream: true }>
export function useExtractResume(
  props: HookInput<'ExtractResume', { stream?: boolean }> = {},
): HookOutput<'ExtractResume', { stream: true }> | HookOutput<'ExtractResume', { stream: false }> {
  let action: ServerAction = Actions.ExtractResume;
  if (isStreamingProps(props)) {
    action = StreamingActions.ExtractResume;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the ExtractResumeNoStructure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - raw_text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useExtractResumeNoStructure({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useExtractResumeNoStructure({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResumeNoStructure(props: HookInput<'ExtractResumeNoStructure', { stream: false }>): HookOutput<'ExtractResumeNoStructure', { stream: false }>
export function useExtractResumeNoStructure(props?: HookInput<'ExtractResumeNoStructure', { stream?: true }>): HookOutput<'ExtractResumeNoStructure', { stream: true }>
export function useExtractResumeNoStructure(
  props: HookInput<'ExtractResumeNoStructure', { stream?: boolean }> = {},
): HookOutput<'ExtractResumeNoStructure', { stream: true }> | HookOutput<'ExtractResumeNoStructure', { stream: false }> {
  let action: ServerAction = Actions.ExtractResumeNoStructure;
  if (isStreamingProps(props)) {
    action = StreamingActions.ExtractResumeNoStructure;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the GenerateGuide BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - arg: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Guide
 * - **Streaming Partial:** partial_types.Guide
 * - **Streaming Final:** Guide
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateGuide({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateGuide({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateGuide(props: HookInput<'GenerateGuide', { stream: false }>): HookOutput<'GenerateGuide', { stream: false }>
export function useGenerateGuide(props?: HookInput<'GenerateGuide', { stream?: true }>): HookOutput<'GenerateGuide', { stream: true }>
export function useGenerateGuide(
  props: HookInput<'GenerateGuide', { stream?: boolean }> = {},
): HookOutput<'GenerateGuide', { stream: true }> | HookOutput<'GenerateGuide', { stream: false }> {
  let action: ServerAction = Actions.GenerateGuide;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateGuide;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the GenerateReplies BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - tweets: Tweet[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Reply[]
 * - **Streaming Partial:** (partial_types.Reply | null)[]
 * - **Streaming Final:** Reply[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGenerateReplies({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGenerateReplies({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGenerateReplies(props: HookInput<'GenerateReplies', { stream: false }>): HookOutput<'GenerateReplies', { stream: false }>
export function useGenerateReplies(props?: HookInput<'GenerateReplies', { stream?: true }>): HookOutput<'GenerateReplies', { stream: true }>
export function useGenerateReplies(
  props: HookInput<'GenerateReplies', { stream?: boolean }> = {},
): HookOutput<'GenerateReplies', { stream: true }> | HookOutput<'GenerateReplies', { stream: false }> {
  let action: ServerAction = Actions.GenerateReplies;
  if (isStreamingProps(props)) {
    action = StreamingActions.GenerateReplies;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the GetRecipe BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - arg: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Recipe
 * - **Streaming Partial:** partial_types.Recipe
 * - **Streaming Final:** Recipe
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useGetRecipe({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useGetRecipe({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetRecipe(props: HookInput<'GetRecipe', { stream: false }>): HookOutput<'GetRecipe', { stream: false }>
export function useGetRecipe(props?: HookInput<'GetRecipe', { stream?: true }>): HookOutput<'GetRecipe', { stream: true }>
export function useGetRecipe(
  props: HookInput<'GetRecipe', { stream?: boolean }> = {},
): HookOutput<'GetRecipe', { stream: true }> | HookOutput<'GetRecipe', { stream: false }> {
  let action: ServerAction = Actions.GetRecipe;
  if (isStreamingProps(props)) {
    action = StreamingActions.GetRecipe;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the IdentifyVehicleSide BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - vanImage: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** VehicleSideResponse
 * - **Streaming Partial:** partial_types.VehicleSideResponse
 * - **Streaming Final:** VehicleSideResponse
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useIdentifyVehicleSide({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useIdentifyVehicleSide({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useIdentifyVehicleSide(props: HookInput<'IdentifyVehicleSide', { stream: false }>): HookOutput<'IdentifyVehicleSide', { stream: false }>
export function useIdentifyVehicleSide(props?: HookInput<'IdentifyVehicleSide', { stream?: true }>): HookOutput<'IdentifyVehicleSide', { stream: true }>
export function useIdentifyVehicleSide(
  props: HookInput<'IdentifyVehicleSide', { stream?: boolean }> = {},
): HookOutput<'IdentifyVehicleSide', { stream: true }> | HookOutput<'IdentifyVehicleSide', { stream: false }> {
  let action: ServerAction = Actions.IdentifyVehicleSide;
  if (isStreamingProps(props)) {
    action = StreamingActions.IdentifyVehicleSide;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the IsResume BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - raw_text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** boolean
 * - **Streaming Partial:** boolean
 * - **Streaming Final:** boolean
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useIsResume({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useIsResume({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useIsResume(props: HookInput<'IsResume', { stream: false }>): HookOutput<'IsResume', { stream: false }>
export function useIsResume(props?: HookInput<'IsResume', { stream?: true }>): HookOutput<'IsResume', { stream: true }>
export function useIsResume(
  props: HookInput<'IsResume', { stream?: boolean }> = {},
): HookOutput<'IsResume', { stream: true }> | HookOutput<'IsResume', { stream: false }> {
  let action: ServerAction = Actions.IsResume;
  if (isStreamingProps(props)) {
    action = StreamingActions.IsResume;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the MakeSemanticContainer BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SemanticContainer
 * - **Streaming Partial:** partial_types.SemanticContainer
 * - **Streaming Final:** SemanticContainer
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useMakeSemanticContainer({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useMakeSemanticContainer({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeSemanticContainer(props: HookInput<'MakeSemanticContainer', { stream: false }>): HookOutput<'MakeSemanticContainer', { stream: false }>
export function useMakeSemanticContainer(props?: HookInput<'MakeSemanticContainer', { stream?: true }>): HookOutput<'MakeSemanticContainer', { stream: true }>
export function useMakeSemanticContainer(
  props: HookInput<'MakeSemanticContainer', { stream?: boolean }> = {},
): HookOutput<'MakeSemanticContainer', { stream: true }> | HookOutput<'MakeSemanticContainer', { stream: false }> {
  let action: ServerAction = Actions.MakeSemanticContainer;
  if (isStreamingProps(props)) {
    action = StreamingActions.MakeSemanticContainer;
  }
  return useBamlAction(action, props as HookInput)
}
/**
 * A specialized hook for the SelectTools BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - state: State
 *
 * - query: TodoQuery
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (MessageToUser | AddItem | AdjustItem)[]
 * - **Streaming Partial:** ((partial_types.MessageToUser | null) | (types.AddItem | null) | (types.AdjustItem | null) | null)[]
 * - **Streaming Final:** (MessageToUser | AddItem | AdjustItem)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isLoading, mutate } = useSelectTools({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamData, isLoading, error, mutate } = useSelectTools({
 *   stream: true | undefined,
 *   onStreamData: (partial) => console.log('Partial update:', partial),
 *   onFinalData: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSelectTools(props: HookInput<'SelectTools', { stream: false }>): HookOutput<'SelectTools', { stream: false }>
export function useSelectTools(props?: HookInput<'SelectTools', { stream?: true }>): HookOutput<'SelectTools', { stream: true }>
export function useSelectTools(
  props: HookInput<'SelectTools', { stream?: boolean }> = {},
): HookOutput<'SelectTools', { stream: true }> | HookOutput<'SelectTools', { stream: false }> {
  let action: ServerAction = Actions.SelectTools;
  if (isStreamingProps(props)) {
    action = StreamingActions.SelectTools;
  }
  return useBamlAction(action, props as HookInput)
}